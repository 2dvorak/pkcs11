/* Filename is not ending in .c because it will then be picked up by cgo twice */
#define CK_PTR *
#define CK_DEFINE_FUNCTION(returnType, name) returnType name
#define CK_DECLARE_FUNCTION(returnType, name) returnType name
#define CK_DECLARE_FUNCTION_POINTER(returnType, name) returnType (* name)
#define CK_CALLBACK_FUNCTION(returnType, name) returnType (* name)
#ifndef NULL_PTR
#define NULL_PTR 0
#endif
#include "pkcs11.h"
#include <stdlib.h>
#include <stdio.h>
#include <ltdl.h>

struct ctx {
	lt_dlhandle handle;
	CK_FUNCTION_LIST_PTR sym;
};

// New initializes a ctx and fills the symbol table.
struct ctx * New(const char *module) {
	if (lt_dlinit() != 0) {
		return NULL;
	}
	CK_C_GetFunctionList list;
	struct ctx *c=  calloc(1, sizeof(struct ctx));
        if (!c) {
                return NULL;
        }
	c->handle = lt_dlopen(module);
	if (c->handle == NULL) {
		free(c);
		return NULL;
	}
	list = (CK_C_GetFunctionList) lt_dlsym(c->handle, "C_GetFunctionList");
	if (list == NULL) {
		free(c);
		return NULL;
	}
	list(&c->sym);
	return c;
}

// Destroy cleans up a ctx.
void Destroy(struct ctx *c) {
        if (!c) {
                return;
        }
	if (c->handle == NULL) {
		return;
	}
	if (lt_dlclose(c->handle) < 0) {
		return;
	}
	lt_dlexit();
	free(c);
}

CK_RV Go_C_Initialize(struct ctx *c) {
	CK_C_INITIALIZE_ARGS InitArgs = {NULL, NULL, NULL, NULL, CKF_OS_LOCKING_OK, NULL};
	return ((CK_FUNCTION_LIST_PTR)c->sym)->C_Initialize( (CK_VOID_PTR) &InitArgs);
}

CK_RV Go_C_Finalize(struct ctx *c) {
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_Finalize(NULL_PTR);
}

CK_RV Go_C_GetInfo(struct ctx *c, CK_INFO_PTR *pInfo) {
        *pInfo = calloc(1, sizeof(CK_INFO));
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetInfo(*pInfo);
}

CK_RV Go_C_GetSlotList(struct ctx *c, CK_BBOOL tokenPresent, CK_SLOT_ID_PTR *pSlotList, CK_ULONG_PTR pCount) {
        CK_RV rv;
        rv = ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetSlotList(tokenPresent, NULL_PTR, pCount);
        if (rv != CKR_OK) {
                return rv;
        }
        *pSlotList = calloc(1, sizeof(CK_SLOT_ID) * *pCount);
        if (!*pSlotList) {
                return CKR_GENERAL_ERROR; 
        }
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetSlotList(tokenPresent, *pSlotList, pCount);
}

CK_RV Go_C_GetSlotInfo(struct ctx *c, CK_SLOT_ID slotID, CK_SLOT_INFO_PTR *pInfo) {
        *pInfo = calloc(1, sizeof(CK_SLOT_INFO));
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetSlotInfo(slotID, *pInfo);
}

CK_RV Go_C_GetTokenInfo(struct ctx *c, CK_SLOT_ID slotID, CK_TOKEN_INFO_PTR *pInfo) {
        *pInfo = calloc(1, sizeof(CK_TOKEN_INFO));
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetTokenInfo(slotID, *pInfo);
}

CK_RV Go_C_GetMechanismList(struct ctx *c, CK_SLOT_ID slotID, CK_MECHANISM_TYPE_PTR *pMechList, CK_ULONG_PTR pCount) {
        CK_RV rv;
        rv = ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetMechanismList(slotID, NULL_PTR, pCount);
        if (rv != CKR_OK) {
                return rv;
        }
        *pMechList = calloc(1, sizeof(CK_MECHANISM_TYPE) * *pCount);
        if (!*pMechList) {
                return CKR_GENERAL_ERROR; 
        }
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetMechanismList(slotID, *pMechList, pCount);
}

CK_RV Go_C_GetMechanismInfo(struct ctx *c, CK_SLOT_ID slotID, CK_MECHANISM_TYPE type, CK_MECHANISM_INFO_PTR *pInfo) {
        *pInfo = calloc(1, sizeof(CK_MECHANISM_INFO));
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetMechanismInfo(slotID, type, *pInfo);
}

CK_RV Go_C_InitToken(struct ctx *c, CK_SLOT_ID slotID, char * pPin, CK_ULONG pinLen, char * label) {
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_InitToken(slotID, (CK_UTF8CHAR_PTR)pPin, pinLen, (CK_UTF8CHAR_PTR)label);
}

// Session management

CK_RV Go_C_OpenSession(struct ctx *c, CK_SLOT_ID slotID, CK_FLAGS flags, CK_SESSION_HANDLE_PTR phSession) {
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_OpenSession(slotID, flags, NULL, NULL, phSession);
}

CK_RV Go_C_CloseSession(struct ctx *c, CK_SESSION_HANDLE phSession) {
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_CloseSession(phSession);
}

CK_RV Go_C_CloseAllSessions(struct ctx *c, CK_SLOT_ID slotID) {
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_CloseAllSessions(slotID);
}

CK_RV Go_C_GetSessionInfo(struct ctx *c, CK_SESSION_HANDLE hSession, CK_SESSION_INFO_PTR *pInfo) {
        *pInfo = calloc(1, sizeof(CK_SESSION_INFO));
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetSessionInfo(hSession, *pInfo);
}

CK_RV Go_C_InitPIN(struct ctx *c, CK_SESSION_HANDLE hSession, char * pin, CK_ULONG pinLen) {
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_InitPIN(hSession,(CK_UTF8CHAR_PTR)pin, pinLen);
}

CK_RV Go_C_SetPIN(struct ctx *c, CK_SESSION_HANDLE hSession, char * oldPin, CK_ULONG oldPinLen, char * newPin, CK_ULONG newPinLen) {
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_SetPIN(hSession,(CK_UTF8CHAR_PTR)oldPin, oldPinLen, (CK_UTF8CHAR_PTR)newPin, newPinLen);
}

CK_RV Go_C_GetAttributeValue(struct ctx *c, CK_SESSION_HANDLE hSession, CK_OBJECT_HANDLE hObject, CK_ATTRIBUTE_PTR pTemplate, CK_ULONG *ulCount) {
        // TODO(mg): check ulcount and ptemplate
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetAttributeValue(hSession, hObject, pTemplate, *ulCount);
}

CK_RV Go_C_SetAttributeValue(struct ctx *c, CK_SESSION_HANDLE hSession, CK_OBJECT_HANDLE hObject, CK_ATTRIBUTE_PTR pTemplate, CK_ULONG ulCount) {
        // TODO(mg)
        return 0;
}

// Object management

CK_RV Go_C_CreateObject(struct ctx *c, CK_SESSION_HANDLE phSession, CK_ATTRIBUTE_PTR pTemplate, CK_ULONG ulCount, CK_OBJECT_HANDLE_PTR *phObject) {
        
        *phObject = calloc(1, sizeof(CK_OBJECT_HANDLE));
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_CreateObject(phSession, pTemplate, ulCount, *phObject);

}

CK_RV Go_C_DestroyObject(struct ctx *c, CK_SESSION_HANDLE hSession, CK_OBJECT_HANDLE hObject) {
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_DestroyObject(hSession, hObject);
}
