/* Filename is not ending in .c because it will then be picked up by cgo twice */
#define CK_PTR *
#define CK_DEFINE_FUNCTION(returnType, name) returnType name
#define CK_DECLARE_FUNCTION(returnType, name) returnType name
#define CK_DECLARE_FUNCTION_POINTER(returnType, name) returnType (* name)
#define CK_CALLBACK_FUNCTION(returnType, name) returnType (* name)
#ifndef NULL_PTR
#define NULL_PTR 0
#endif
#include "pkcs11.h"
#include <stdlib.h>
#include <stdio.h>
#include <ltdl.h>

struct ctx {
	lt_dlhandle handle;
	CK_FUNCTION_LIST_PTR sym;
};

// New initializes a ctx and fills the symbol table.
struct ctx * New(const char *module) {
	if (lt_dlinit() != 0) {
		return NULL;
	}
	CK_C_GetFunctionList list;
	struct ctx *c=  calloc(1, sizeof(struct ctx));
        if (!c) {
                return NULL;
        }
	c->handle = lt_dlopen(module);
	if (c->handle == NULL) {
		free(c);
		return NULL;
	}
	list = (CK_C_GetFunctionList) lt_dlsym(c->handle, "C_GetFunctionList");
	if (list == NULL) {
		free(c);
		return NULL;
	}
	list(&c->sym);
	return c;
}

// Destroy cleans up a ctx
void Destroy(struct ctx *c) {
        if (!c) {
                return;
        }
	if (c->handle == NULL) {
		return;
	}
	if (lt_dlclose(c->handle) < 0) {
		return;
	}
	lt_dlexit();
	free(c);
}

CK_RV Go_C_Initialize(struct ctx *c) {
	CK_C_INITIALIZE_ARGS InitArgs = {NULL, NULL, NULL, NULL, CKF_OS_LOCKING_OK, NULL};
	return ((CK_FUNCTION_LIST_PTR)c->sym)->C_Initialize( (CK_VOID_PTR) &InitArgs);
}

CK_RV Go_C_Finalize(struct ctx *c) {
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_Finalize(NULL_PTR);
}

CK_RV Go_C_GetInfo(struct ctx *c, CK_INFO_PTR *pInfo) {
        *pInfo = calloc(1, sizeof(CK_INFO));
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetInfo(*pInfo);
}

CK_RV Go_C_GetSlotList(struct ctx *c, CK_BBOOL tokenPresent, CK_SLOT_ID_PTR *pSlotList, CK_ULONG_PTR pCount) {
        CK_RV rv;
        rv = ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetSlotList(tokenPresent, NULL_PTR, pCount);
        if (rv != CKR_OK) {
                return rv;
        }
        *pSlotList = calloc(1, sizeof(CK_SLOT_ID) * *pCount);
        if (!*pSlotList) {
                return CKR_GENERAL_ERROR; 
        }
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetSlotList(tokenPresent, *pSlotList, pCount);
}

CK_RV Go_C_GetSlotInfo(struct ctx *c, CK_SLOT_ID slotID, CK_SLOT_INFO_PTR *pInfo) {
        *pInfo = calloc(1, sizeof(CK_SLOT_INFO));
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetSlotInfo(slotID, *pInfo);
}

CK_RV Go_C_GetTokenInfo(struct ctx *c, CK_SLOT_ID slotID, CK_TOKEN_INFO_PTR *pInfo) {
        *pInfo = calloc(1, sizeof(CK_TOKEN_INFO));
        return ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetTokenInfo(slotID, *pInfo);
}

/*
        *slots = calloc(1, sizeof(CK_SLOT_INFO) * *nslots);
        *tokens = calloc(1, sizeof(CK_TOKEN_INFO) * *nslots);
        if (!*slots || !*tokens) {
                return CKR_GENERAL_ERROR;
        }
        for (i = 0; i < *nslots; i++) {
                rv = ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetSlotInfo(ids[i], slots[i]);
                // TODO: return code
                if ( (slots[i]->flags & CKF_TOKEN_PRESENT) == CKF_TOKEN_PRESENT) {
                        rv = ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetTokenInfo(ids[i], tokens[i]);
                        // TODO(mg): rv return code
                }
        }
        return CKR_OK;
}

CK_RV InitToken(struct ctx *c, CK_TOKEN_INFO_PTR *t, uint id, char * pin, uint pinlen, char * label) {
        CK_RV rv;
        rv = ((CK_FUNCTION_LIST_PTR)c->sym)->C_InitToken((CK_SLOT_ID)id, (CK_UTF8CHAR_PTR)pin, (CK_ULONG)pinlen, (CK_UTF8CHAR_PTR)label);
        if (rv != CKR_OK) {
                return rv;
        }
        *t = calloc(1, sizeof(CK_TOKEN_INFO));
        // re-Read token
        rv = ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetTokenInfo((CK_SLOT_ID)id, *t);
        if (rv != 0) {
                // ...
        }
        // And some more
        return CKR_OK;
}
*/
